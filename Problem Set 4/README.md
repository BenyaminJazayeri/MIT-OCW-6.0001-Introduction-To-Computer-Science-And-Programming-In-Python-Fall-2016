# Caesar Cipher and Substitution Cipher with OOP

A recursive permutation generator connected to two encryption systems built with OOP. Demonstrates class inheritance and composing components across files.

## Implementation

### Part A — Recursive Permutations (`ps4a.py`)

- `get_insertions(letter, permutations)` — inserts a letter at every position in every string in a list
- `get_permutations(sequence)` — base case returns a single-character string; recursive case inserts the first character into all permutations of the remaining characters

### Part B — Caesar Cipher (`ps4b.py`)

- `Message` — base class with `build_shift_dict()` (creates a shift mapping for all 26 letters, preserving case) and `apply_shift()` (applies the cipher)
- `PlaintextMessage(Message)` — stores shift value, builds encryption dict, generates encrypted text
- `CiphertextMessage(Message)` — `decrypt_message()` tries all 26 shifts and returns the one producing the most valid English words. Successfully decrypts an encrypted story file

### Part C — Substitution Cipher (`ps4c.py`)

- `SubMessage` — `build_transpose_dict()` maps vowels according to a given permutation while consonants remain unchanged; `apply_transpose()` applies the mapping
- `EncryptedSubMessage(SubMessage)` — `decrypt_message()` tries all 120 vowel permutations (5! = 120, generated by `get_permutations` from Part A) and returns the decryption yielding the most valid English words
